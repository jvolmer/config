#+TITLE: Use emacs as an IDE
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/lisp/code.el

#+begin_src emacs-lisp
  
  (provide 'code)
  
#+end_src

Activate it

#+begin_src emacs-lisp

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :custom
    (lsp-keymap-prefix "C-c l")

    ;; headline
    (lsp-headerline-breadcrump-enable t)

    ;; in code
    (lsp-diagnostics-provider :flycheck) ;; undercurl errors
    (lsp-enable-symbol-highlighting t)
    (lsp-lens-enable nil) ;; additional infos above classes and methods
    (lsp-ui-doc-enable nil) ;; pop-up
    (lsp-completion-provider :none) ;; manually with completion-at-point
    (lsp-enable-on-type-formatting nil)

    ;; sidebar
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-code-actions t)
    (lsp-ui-sideline-show-diagnostics t)
    (lsp-ui-sideline-show-hover nil)

    ;; modeline
    (lsp-modeline-diagnostics-enable t)
    (lsp-modeline-code-actions-enable t)

    ;; minibuffer
    (lsp-eldoc-enable-hover t) ;; one-line signature
    (lsp-signature-auto-activate t)
    (lsp-signature-render-documentation nil) 

    :config
    (lsp-enable-which-key-integration t)
    (general-define-key :keymaps 'lsp-mode-map
      (concat lsp-keymap-prefix " g b") '(xref-go-back :which-key "back"))
    (add-hook 'lsp-mode-hook (lambda () (add-hook 'before-save-hook #'lsp-format-buffer))))

#+end_src

** Features

*** Navigation
Via ~C-c l g <..>~
Go back: ~xref-pop-marker-stack~ (~M-,~)

(or ~xref-find-definitions~, ~xref-find-references~)                              

*** Refactoring
~lsp-rename~ (~C-c l r r~)

*** Actions
~lsp-execute-code-action~ ( ~C-c l a a~)

*** Formatting
~lsp-format-buffer~ (~C-c l = =~)
Configurable via ~lsp-<language>-format~
There can be better packages for each language individually

*** Diagnostics
(see flycheck below)
- Show warnings/errors at point ~C-h .~

*** Documentation
Shows signature in minibuffer
For full docu: ~lsp-describe-thing-at-point~ (~C-c l h h~)

*** Information
~lsp-ui-imenu~ (from lsp-ui package)

*** Completion
(see company package below)
 ~completion-at-point~

* Improved completion

#+begin_src emacs-lisp
  
  (use-package company
    :after lsp-mode ;; use this for lsp completion, otherwise ivy
    :hook (prog-mode . company-mode)
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0)
    ;; otherwise does not find clang executable
    ;; (company-clang-executable "/usr/bin/clang-8")
    :bind
    (:map company-active-map ("<tab>" . company-complete-selection))
    (:map lsp-mode-map
      ("<tab>" . company-indent-or-complete-common)
      ("C-c l c" . completion-at-point)))
  
#+end_src

Nicer interface (with symbols)
#+begin_src emacs-lisp
  
  (use-package company-box
    :hook (company-mode . company-box-mode))
  
#+end_src

Integration with prescient to sort proposals prefering last and frequently used ones (no filtering)
#+begin_src emacs-lisp
  
  (use-package company-prescient
    :hook (company-mode . company-prescient-mode))
  
#+end_src

* Higher level UI features

#+begin_src emacs-lisp
  
    (use-package lsp-ui
      :hook (lsp-mode . lsp-ui-mode))
  
#+end_src

More UI stuff, e.g. peeking or imenu (https://github.com/emacs-lsp/lsp-iu)

* Treemacs

#+begin_src emacs-lisp
  
  (use-package lsp-treemacs
    :after lsp)
  
#+end_src

See file system with ~treemacs~

See symbols with ~lsp-treemacs-symbols~

Possibly treemacs-projectile can be interesting.

* Search symbol in project

Search e.g. for class name in project with ~lsp-ivy~

#+begin_src emacs-lisp
  
  (use-package lsp-ivy
    :after lsp)
  
#+end_src

* Diagnostics

#+begin_src emacs-lisp

  (use-package flycheck
    :after lsp)

#+end_src

Menu: =C-c !=

* Specific language
You need to install the language server for the particular language you use, have a look at https://emacs-lsp.github.io/lsp-mode/page/languages/

** C++

#+begin_src emacs-lisp

   (add-hook 'c++-mode-hook #'lsp)
   (add-hook 'c-mode-hook #'lsp)
   (add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))
   ;; (setq c-default-style "stroustrup")

#+end_src

Helpful Commands
| flycheck-copy-errors-as-kill | C-c ! C-w | Copy all messages of errors at point            |
| projectile-find-other-file   | C-p p a   | Switch between header and source file           |
| find-file-at-point           | g f       | Open file at point                              |
| c-indent-exp                 | C-M-q     | Indent content of single parenthetical grouping |
|                              |           | Position point before beginning of grouping     |
| goto-last-change             | g ;       | go to last change in current buffer             |
| goto-last-change-reverse     | g ,       | go to next change in current buffer             |

My own build menu
#+begin_src emacs-lisp
  
  (general-create-definer ec/cmake
    :keymaps '(cmake-mode-map c++-mode-map c-mode-map)
    :prefix "C-c m")
  
  (ec/cmake
   "" '(:ignore t :which-key "cmake")
   "c" '(me/c++/configure :which-key "configure")
   "i" '(me/c++/install :which-key "install dependencies")
   "m" '(me/c++/build :which-key "make")
   "t" '(me/c++/test :which-key "test"))
  
  (defun me/c++/configure ()
    "Generate build system"
    (interactive)
    (if (me/uses-conan-p) (me/c++/install))
    (me/run-command-in-project-root "cmake -S . -B build"))
  
  (defun me/uses-conan-p ()
    (file-exists-p (concat (me/project-root) "conanfile.txt")))
  
  (defun me/c++/install ()
    "Install dependencies via conan"
    (interactive)
    (me/run-command-in-project-root "conan install --install-folder build ."))
  
  (defun me/c++/build ()
    "Build project and create compile_commands.json"
    (interactive)
    (me/run-command-in-project-root "cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=YES --build build"))
  
  (defun me/c++/test ()
    "Run tests in project"
    (interactive)
    (me/run-command-in-project-root "cmake --build build --target test"))
  
  (defun me/run-command-in-project-root (command)
    "Run command in project root"
    (let ((default-directory (me/project-root)))
      (shell-command command)))
  
  (defun me/project-root ()
    "Return the current project root when applicable or nil."
    (when-let (project (project-current))
      (project-root project)))
  
#+end_src

*** Language server

Currently I use clangd

**** Config for ccls (not used at the moment)

#+begin_src emacs-lisp :tangle no

  (use-package ccls
    :hook ((c-mode c++-mode objc-mode cuda-mode) . lsp))
    :custom
    (ccls-args (list (concat "-init={"
                             ;; find compile_commands.json in build directory
                             "  \"compilationDatabaseDirectory\": \"build\" "
                             ;; cache to home instead of to each project separately
                             ;; " , "
                             ;; "  \"cache\":{"
                             ;; "    \"directory\":"
                             ;; "      \"" (getenv "HOME") "/.cache/ccls\""
                             ;; "  }"
                             "}"))))

#+end_src

** Rust
https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/

#+begin_src emacs-lisp
  
  (use-package rustic ;; rustic improves rust-mode
    :hook (rustic-mode . lsp)
    :custom
  
    ;; what to use for checking on-save (default is 'check')
    (lsp-rust-analyzer-cargo-watch-command "clippy") ;; run clippy with rust-run-clippy
  
    (rustic-format-on-save t)
  
    :config
    (general-define-key "C-c C-c" '(:ignore t :which-key "rustic")))
  
  #+end_src

Rustic commands under ~C-c C-c~ or show them in extra buffer with ~C-c C-p~
Add/remove/update dependencies with ~rustic-cargo-...~
Others commands: ~rustic-cargo-...~ and ~lsp-rust...~

Possibly interesting: Show analyzer status with ~lsp-rust-analyzer-status~

You can have inline-documentation
  
** Javascript

#+begin_src emacs-lisp

  (use-package typescript-mode
    :mode "\\.js\\'"
    :hook (typescript-mode . lsp))

#+end_src

Language server: Currently I use ts-ls (need to install typescript-language-server and typescript packages
