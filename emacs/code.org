#+TITLE: Use emacs as an IDE
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/lisp/code.el

#+begin_src emacs-lisp
  
  (provide 'code)
  
#+end_src

Activate it

#+begin_src emacs-lisp
  
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :custom
    (lsp-keymap-prefix "C-c l")
  
    ;; make it less flashy
    (lsp-eldoc-hook nil)
    (lsp-enable-symbol-highlighting nil)
    (lsp-signature-auto-activate nil)
  
    (lsp-eldoc-render-all t)
    (lsp-enable-on-type-formatting nil)
  
    :config
    (lsp-enable-which-key-integration t))
  
#+end_src
** Features

*** Completion
 ~completion-at-point~
 
*** Signatures
Shows them in echo area a bottom
Cycle through with ~M-p~ and ~M-n~

*** Navigation
~lsp-find-reference~ (~C-c l g r~)
~lsp-find-definition~ (~C-c l g g~)

*** Refactoring
~lsp-rename~ (~C-c l r r~)

*** Formatting
~lsp-format-buffer~ (~C-c l = =~)
Configurable via ~lsp-<language>-format~
There can be better packages for each language individually

*** Diagnostics
using flymake
- List: ~flymake-show-diagnostics-buffer~
- Show warnings/errors at point ~C-h .~

*** Actions
~lsp-execute-code-action~ ( ~C-c l a a~)

*** Documentation
~lsp-describe-thing-at-point~

* Improved completion

#+begin_src emacs-lisp
  
  (use-package company
    :after lsp-mode ;; use this for lsp completion, otherwise ivy
    :hook (prog-mode . company-mode)
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0)
    ;; otherwise does not find clang executable
    (company-clang-executable "/usr/bin/clang-8"))
  
#+end_src

Nicer interface (with symbols)

#+begin_src emacs-lisp
  
  (use-package company-box
    :hook (company-mode . company-box-mode))
  
#+end_src

Integration with prescient to sort proposals prefering last and frequently used ones (no filtering)

#+begin_src emacs-lisp
  
  (use-package company-prescient
    :hook (company-mode . company-prescient-mode))
  
#+end_src

* Higher level UI features

#+begin_src emacs-lisp
  
    (use-package lsp-ui
      :hook (lsp-mode . lsp-ui-mode)
      :custom
      (lsp-ui-doc-enable nil))
  
#+end_src

There are different modules:
- lsp-ui-sideline: shows information of symbols on the current line, also flycheck diagnostics and code actions
- lsp-ui-peek: peek to definition or reference ~lsp-ui-peek-find-references~ (~C-c l G r~)
- lsp-ui-doc: shows object documentation at point in a child frame (go in and out of frame with ~lsp-ui-doc-(un)focus-frame~ 
- lsp-ui-imenu

There are a lot of options and things you can toggle, have a look at https://github.com/emacs-lsp/lsp-iu. Toogles can also be changed with ~C-c l T~.

* Treemacs

#+begin_src emacs-lisp
  
  (use-package lsp-treemacs
    :after lsp)
  
#+end_src

See file system with ~treemacs~

See symbols with ~lsp-treemacs-symbols~

Possibly treemacs-projectile can be interesting.

* Search symbol in project

Search e.g. for class name in project with ~lsp-ivy~

#+begin_src emacs-lisp
    
    (use-package lsp-ivy
      :after lsp)
    
#+end_src

* Errors

#+begin_src emacs-lisp
    
    (use-package flycheck
      :after lsp)
    
#+end_src

Display list of errors and warnings with ~flycheck-list_errors~

* Specific language

You need to install the language server for the particular language you use, have a look at https://emacs-lsp.github.io/lsp-mode/page/languages/

** Rust
https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/

#+begin_src emacs-lisp
  
  (use-package rustic ;; rustic improves rust-mode
    :hook (rustic-mode . lsp)
    :custom
  
    ;; what to use for checking on-save (default is 'check')
    (lsp-rust-analyzer-cargo-watch-command "clippy") ;; run clippy with rust-run-clippy
  
    (rustic-format-on-save t))
  
  #+end_src

Possibly interesting commands:
| lsp-rust-analyzer-status | Show analyzer status |
| lsp-ui-imenu             | Open ui menu         |
| flycheck-list-errors     |                      |

Rustic commands under ~C-c C-c~ or ~C-c C-p~
Add/remove/update dependencies with ~rustic-cargo-...~
Others commands: ~rustic-cargo-...~ and ~lsp-rust...~
M-. xref-find-definitions Find definition of identifier at point (~xref-find-references~)
M-, xref-pop-marker-stack Pop back to where M-. was last invoked
Perhaps: M-? for lsp-references and M-j for lsp-ui-imenu

Only ~lsp-find-implementations~ has no xref version, for others use xref

You can have inline-documentation
  
** C++

#+begin_src emacs-lisp
  
  (use-package ccls
    :hook ((c-mode c++-mode objc-mode cuda-mode) . lsp)
    :custom
    (ccls-args (list (concat "-init={"
                             ;; find compile_commands.json in build directory
                             "  \"compilationDatabaseDirectory\": \"build\","
                             ;; cache to home instead of to each project separately
                             "  \"cache\":{"
                             "    \"directory\":"
                             "      \"" (getenv "HOME") "/.cache/ccls\""
                             "  }"
                             "}"))))
  
  (add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))
  
#+end_src

My own build menu
#+begin_src emacs-lisp
  
  (general-create-definer ec/cmake
    :keymaps '(cmake-mode-map c++-mode-map c-mode-map)
    :prefix "C-c m")
  
  (ec/cmake
   "" '(:ignore t :which-key "cmake")
   "c" '(me/c++/configure :which-key "configure")
   "i" '(me/c++/install :which-key "install dependencies")
   "m" '(me/c++/build :which-key "make")
   "t" '(me/c++/test :which-key "test"))
  
  (defun me/c++/configure ()
    "Generate build system"
    (interactive)
    (if (me/uses-conan-p) (me/c++/install))
    (me/run-command-in-project-root "cmake -S . -B build"))
  
  (defun me/uses-conan-p ()
    (file-exists-p (concat (me/project-root) "conanfile.txt")))
  
  (defun me/c++/install ()
    "Install dependencies via conan"
    (interactive)
    (me/run-command-in-project-root "conan install --install-folder build ."))
  
  (defun me/c++/build ()
    "Build project and create compile_commands.json"
    (interactive)
    (me/run-command-in-project-root "cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=YES --build build"))
  
  (defun me/c++/test ()
    "Run tests in project"
    (interactive)
    (me/run-command-in-project-root "cmake --build build --target test"))
  
  (defun me/run-command-in-project-root (command)
    "Run command in project root"
    (let ((default-directory (me/project-root)))
      (shell-command command)))
  
  (defun me/project-root ()
    "Return the current project root when applicable or nil."
    (when-let (project (project-current))
      (project-root project)))
  
#+end_src

To reindent the contents of a single parenthetical grouping, position point before the beginning of the grouping: ~C-M-q~
